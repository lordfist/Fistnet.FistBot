<?xml version="1.0" encoding="utf-8" ?>
<Template xmlns="http://fuzzyeye.org/FistCore/TemplateEngine/Template.xsd" >
  <Header>
    <Title>SP wrapper and Catalog classes</Title>
    <Description>FistCore XML template which generates Catalog and SP classes.</Description>
    <Family>SP</Family>
  </Header>
  <Variables>
    <Variable>
      <Name>ProjectNamespace</Name>
      <Description>C# namespace for FistCore project.</Description>
      <DefaultValue>MySolution.FistCore</DefaultValue>
    </Variable>
    <Variable>
      <Name>DbmsTypeAppSettingsKey</Name>
      <Description>App settings entry which conains the target DBMS.</Description>
      <DefaultValue>MySolution.DbmsType</DefaultValue>
    </Variable>
    <Variable>
      <Name>ConnectionStringName</Name>
      <Description>Name of the connection string in the .config file.</Description>
      <DefaultValue>MySolution.ConnectionString</DefaultValue>
    </Variable>
    <Variable>
      <Name>OutputSubdirectory</Name>
      <Description>Output subdirectory</Description>
      <DefaultValue>Entities</DefaultValue>
    </Variable>
  </Variables>
  <Settings>
    <Setting>
      <Name>FileExtension</Name>
      <Description>File extension</Description>
      <Value>cs</Value>
    </Setting>
    <Setting>
      <Name>FileNameSuffix</Name>
      <Description>Suffix appended to generated file</Description>
      <Value></Value>
    </Setting>
  </Settings>
  <ReferencedAssemblies>
    <Assembly>FistCore.Generator.OrmComponents.dll</Assembly>
    <Assembly>FistCore.Generator.DbMetaData.dll</Assembly>
  </ReferencedAssemblies>
  <Namespaces>
    <Using>System</Using>
    <Using>FistCore.Generator.OrmComponents</Using>
  </Namespaces>
  <InputComponentBuilder>
    <Assembly>FistCore.Generator.OrmComponents</Assembly>
    <Class>FistCore.Generator.OrmComponents.SpComponentBuilder</Class>
  </InputComponentBuilder>
  <TemplateSegments>
    <TemplateSegment Id="CatalogAndSpRoot">
      <![CDATA[// Contains catalog information and stored procedure wrapper classes.
using System;
using System.Configuration;
using System.Data;
using System.Data.SqlTypes;
using System.Data.SqlClient;

using FistCore.Common;
using FistCore.Core;

namespace $Variables["ProjectNamespace"]$
{
	/// <summary>
	/// Catalog used by classes in the $Variables["ProjectNamespace"]$ namespace.
	/// Reads information from *.config file.
	/// </summary>
  [Serializable]
	public sealed class Catalog : ICatalog
	{
		#region ICatalog.

		private static readonly DbmsType dbmsType;
		private static readonly string connectionString;

		static Catalog()
		{
			string cfgDbmsType = ConfigurationManager.AppSettings["$Variables["DbmsTypeAppSettingsKey"]$"];
			if (cfgDbmsType != null)
				dbmsType = (DbmsType)Enum.Parse(typeof(DbmsType), cfgDbmsType);

			if ((ConfigurationManager.ConnectionStrings != null) && (ConfigurationManager.ConnectionStrings["$Variables["ConnectionStringName"]$"] != null))
				connectionString = ConfigurationManager.ConnectionStrings["$Variables["ConnectionStringName"]$"].ConnectionString;
		}

		/// <summary>
		/// Gets database type.
		/// </summary>
		public DbmsType DbmsType
		{
			get { return dbmsType; }
		}

		/// <summary>
		/// Gets connection string.
		/// </summary>
		public string ConnectionString
		{
			get { return connectionString; }
		}

		/// <summary>
		/// Creates a connection provider for this catalog.
		/// </summary>
		/// <returns>Connection provider that connects to this catalog.</returns>
		public IConnectionProvider CreateConnectionProvider()
		{
			DbmsType dbms = this.DbmsType;
			string connString = this.ConnectionString;

			switch (dbms)
			{
				case DbmsType.SqlServer_2008:
				case DbmsType.SqlServer_2005:
				case DbmsType.SqlServer_2000:
				case DbmsType.SqlServer_7:
					// SqlServerConnectionProvider(DbmsType, string, IsolationLevel) constructor overload can be used to specify a custom default isolation level for BeginTransaction() method.
					// BeginTransaction() method will use .NET defaults if a constructor which doesn't accept custom IsolationLevel value is used.
					return new global::FistCore.Core.SqlServer.SqlServerConnectionProvider(dbms, connString);

				//case DbmsType.Oracle_11g:
				//case DbmsType.Oracle_10g:
				//case DbmsType.Oracle_9i:
					//// OracleConnectionProvider(DbmsType, string, IsolationLevel) constructor overload can be used to specify a custom default isolation level for BeginTransaction() method.
					//// BeginTransaction() method will use .NET defaults if a constructor which doesn't accept custom IsolationLevel value is used.
				  //return new global::FistCore.Core.Oracle.OracleConnectionProvider(dbms, connString);

				//FistCore.Core.MySql.dll assembly must be referenced.
				//case DbmsType.MySql_5:
					//return new global::FistCore.Core.MySql.MySqlConnectionProvider(dbms, connString);

				//FistCore.Core.PostgreSql.dll, Npgsql.dll and Mono.Security assemblies must be referenced.
				//case DbmsType.PostgreSql_9:
					//return new global::FistCore.Core.PostgreSql.PostgreSqlConnectionProvider(dbms, connString);

				//FistCore.Core.Firebird.dll and FirebirdSql.Data.FirebirdClient.dll assemblies must be referenced.
				//case DbmsType.Firebird_2:
					//return new global::FistCore.Core.Firebird.FirebirdConnectionProvider(dbms, connString);

				//FistCore.Core.SQLite.dll and System.Data.SQLite.dll assemblies must be referenced. SQLite.Interop.dll must be coppied to execution directory.
				//case DbmsType.SQLite_3:
					//return new global::FistCore.Core.SQLite.SQLiteConnectionProvider(dbms, connString);

				//FistCore.Core.SqlServerCe.dll assembly must be referenced.
				//case DbmsType.SqlServerCe_4:
					//return new global::FistCore.Core.SqlServerCe.SqlServerCeConnectionProvider(dbms, connString);

				case DbmsType.OdbcGeneric:
					return new global::FistCore.Core.Odbc.OdbcConnectionProvider(dbms, connString);

				case DbmsType.OleGeneric:
					return new global::FistCore.Core.OleDb.OleDbConnectionProvider(dbms, connString);

				default:
					throw new Exception("Unsupported DBMS type: " + dbms.ToString() + ".");
			}
		}

		#endregion

		#region Configuration - overriden/obfuscated table and column names.

		const string TableNameOverrideKeyFormat = "$Variables["ProjectNamespace"]$.{0}.TableName";

		/// <summary>Gets overriden/obfuscated table name from application's configuration file.</summary>
		internal static string GetTableNameOverride(string tableName)
		{
			string settingsKey = string.Format(TableNameOverrideKeyFormat, tableName);
			return ConfigurationManager.AppSettings[settingsKey];
		}

		const string ColumnNameOverrideKeyFormat = "$Variables["ProjectNamespace"]$.{0}.{1}.ColumnName";

		/// <summary>Gets overriden/obfuscated column name from application's configuration file.</summary>
		internal static string GetColumnNameOverride(string tableName, string columnName)
		{
			string settingsKey = string.Format(ColumnNameOverrideKeyFormat, tableName, columnName);
			return ConfigurationManager.AppSettings[settingsKey];
		}

		#endregion
	}

	/// <summary>
	/// Contains stored procedure calls.
	/// </summary>
	public static class SP
	{$Generate("StoredProcedure", Input.GetChildren(SpComponentType.SP))$
	}
}]]>
    </TemplateSegment>
    <TemplateSegment Id="StoredProcedure">
      <![CDATA[
		#region $Input.Name$.

		/// <summary>
		/// Executes stored procedure $Input.Name$. Opens new connection.
		/// </summary>
		$Generate("ParameterSummary", Input.GetChildren(SpComponentType.SpParameter, SpParameterCriteria.IsNotDataTableFilledByAdapter))$/// <returns>Data retrieved by stored procedure.</returns>
		public static StoredProcedureResult $Input.MethodName()$($Generate("MethodArgumentFirst", Input.GetChildren(SpComponentType.SpParameter, 0, 1, SpParameterCriteria.IsNotDataTableFilledByAdapter))$$Generate("MethodArgumentOther", Input.GetChildren(SpComponentType.SpParameter, 1, int.MaxValue, SpParameterCriteria.IsNotDataTableFilledByAdapter))$)
		{
			IConnectionProvider conn = new Catalog().CreateConnectionProvider();
			try
			{
				StoredProcedureResult result = $Input.MethodName()$(conn$Generate("PassMethodArgument", Input.GetChildren(SpComponentType.SpParameter, SpParameterCriteria.IsNotDataTableFilledByAdapter))$);
				return result;
			}
			finally
			{
				conn.Dispose();
			}
		}

		/// <summary>
		/// Executes stored procedure $Input.Name$. Uses given connection.
		/// </summary>
		/// <param name="conn">ConnectionProvider.</param>
		$Generate("ParameterSummary", Input.GetChildren(SpComponentType.SpParameter, SpParameterCriteria.IsNotDataTableFilledByAdapter))$/// <returns>Data retrieved by stored procedure.</returns>
		public static StoredProcedureResult $Input.MethodName()$(IConnectionProvider conn$Generate("MethodArgumentOther", Input.GetChildren(SpComponentType.SpParameter, SpParameterCriteria.IsNotDataTableFilledByAdapter))$)
		{
			DbParameterCollection parameters = new DbParameterCollection();
			$Generate("AddDbParameter", Input.GetChildren(SpComponentType.SpParameter))$
			$Generate("AddReturnValueDbParameter", Input, SpCriteria.ShouldGenerateReturnValue)$
			// Execute stored procedure.
			DataSet data = DbUtil.ExecuteMultiQuery(conn, "$Input.Name$", parameters, CommandType.StoredProcedure, 30);
      $Generate("FetchReturnValue", Input, SpCriteria.ShouldGenerateReturnValue)$
			return new StoredProcedureResult(data, retval);
		}

		#endregion
      ]]>
    </TemplateSegment>
    <TemplateSegment Id="ParameterSummary">
      <![CDATA[/// <param name="$Input.MethodParameterName()$">$WriteIf("Input", Input, SpParameterCriteria.IsInput)$$WriteIf("Input/output", Input, SpParameterCriteria.IsInputOutput)$$WriteIf("Output", Input, SpParameterCriteria.IsOutput)$ parameter: $Input.Name$.</param>
		]]>
    </TemplateSegment>
    <TemplateSegment Id="MethodArgumentFirst">
      <![CDATA[$Input.MethodParameterKeyword()$ $Input.MethodArgumentType()$ $Input.MethodParameterName()$]]>
    </TemplateSegment>
    <TemplateSegment Id="MethodArgumentOther">
      <![CDATA[,$WriteIf(" ", Input, SpParameterCriteria.IsRefOrOut)$$Input.MethodParameterKeyword()$ $Input.MethodArgumentType()$ $Input.MethodParameterName()$]]>
    </TemplateSegment>
    <TemplateSegment Id="PassMethodArgument">
      <![CDATA[,$WriteIf(" ", Input, SpParameterCriteria.IsRefOrOut)$$Input.MethodParameterKeyword()$ $Input.MethodParameterName()$]]>
    </TemplateSegment>
    <TemplateSegment Id="AddDbParameter">
      <![CDATA[parameters.Add($Input.NewDbParameter()$);
			]]>
    </TemplateSegment>
    <TemplateSegment Id="AddReturnValueDbParameter">
      <![CDATA[// Return value is fetched as Varchar but it will be converted to integer.
			// This is because some DBMSs also support return types other than integer.
			// Setting SqlDbType to int would throw an exception in such cases.
			parameters.Add(new DbParameter("ReturnValue", DbType.AnsiString, 1000, ParameterDirection.ReturnValue, true, 0, 0, null, DataRowVersion.Proposed, null));
]]>
    </TemplateSegment>
    <TemplateSegment Id="FetchReturnValue">
      <![CDATA[
			// Fetch return value.
			object retval = (parameters["ReturnValue"].Value == DBNull.Value) ? null : parameters["ReturnValue"].Value;
]]>
    </TemplateSegment>
  </TemplateSegments>
</Template>